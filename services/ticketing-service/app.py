"""
Ticketing Service - Managementul evenimentelor și biletelor
Integrare cu Keycloak pentru SSO și RBAC
"""
from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
import os
import jwt
import requests
from datetime import datetime
from functools import wraps
import secrets
import pika
import json
import time

app = Flask(__name__)
CORS(app)

# Configuration
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv(
    'DATABASE_URL',
    'postgresql://eventflow:eventflow@postgres:5432/eventflow'
)
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Keycloak configuration
KEYCLOAK_URL = os.getenv('KEYCLOAK_URL', 'http://keycloak:8080')
KEYCLOAK_REALM = os.getenv('KEYCLOAK_REALM', 'eventflow')
KEYCLOAK_CLIENT_ID = os.getenv('KEYCLOAK_CLIENT_ID', 'eventflow-api')
# URL public (issuer din token)
KEYCLOAK_PUBLIC_URL = os.getenv('KEYCLOAK_PUBLIC_URL', KEYCLOAK_URL)

db = SQLAlchemy(app)


# Models
class Event(db.Model):
    __tablename__ = 'events'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text)
    location = db.Column(db.String(255))
    starts_at = db.Column(db.DateTime, nullable=False)
    total_tickets = db.Column(db.Integer, nullable=False)
    tickets_sold = db.Column(db.Integer, nullable=False, default=0)
    created_by = db.Column(db.String(255))  # keycloak_sub
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    tickets = db.relationship('Ticket', backref='event', lazy=True, cascade='all, delete-orphan')

    def remaining_tickets(self) -> int:
        return max(self.total_tickets - self.tickets_sold, 0)

    def to_dict(self):
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'location': self.location,
            'starts_at': self.starts_at.isoformat() if self.starts_at else None,
            'total_tickets': self.total_tickets,
            'tickets_sold': self.tickets_sold,
            'remaining_tickets': self.remaining_tickets(),
            'created_by': self.created_by,
            'created_at': self.created_at.isoformat() if self.created_at else None,
        }


class Ticket(db.Model):
    __tablename__ = 'tickets'

    id = db.Column(db.Integer, primary_key=True)
    event_id = db.Column(db.Integer, db.ForeignKey('events.id', ondelete='CASCADE'), nullable=False)
    keycloak_sub = db.Column(db.String(255), nullable=False)
    code = db.Column(db.String(32), nullable=False)
    purchased_at = db.Column(db.DateTime, default=datetime.utcnow)
    used_at = db.Column(db.DateTime, nullable=True)
    used_by = db.Column(db.String(255), nullable=True)  # keycloak_sub al staff-ului care a validat

    def to_dict(self):
        return {
            'id': self.id,
            'event_id': self.event_id,
            'keycloak_sub': self.keycloak_sub,
            'code': self.code,
            'purchased_at': self.purchased_at.isoformat() if self.purchased_at else None,
            'used_at': self.used_at.isoformat() if self.used_at else None,
            'used_by': self.used_by,
            'event': self.event.to_dict() if self.event else None,
        }


class BannedUser(db.Model):
    __tablename__ = 'banned_users'

    id = db.Column(db.Integer, primary_key=True)
    keycloak_sub = db.Column(db.String(255), unique=True, nullable=False)
    reason = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    def to_dict(self):
        return {
            'id': self.id,
            'keycloak_sub': self.keycloak_sub,
            'reason': self.reason,
            'created_at': self.created_at.isoformat() if self.created_at else None,
        }


# Auth helpers (copiat și simplificat din User Profile Service)
def verify_token(f):
    """Decorator pentru verificarea JWT token-ului de la Keycloak"""

    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get('Authorization')

        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'No token provided'}), 401

        token = auth_header.split(' ')[1]

        try:
            jwks_url = f"{KEYCLOAK_URL}/realms/{KEYCLOAK_REALM}/protocol/openid-connect/certs"
            jwks_response = requests.get(jwks_url)
            jwks = jwks_response.json()

            unverified_header = jwt.get_unverified_header(token)
            kid = unverified_header.get('kid')

            key = None
            for jwk in jwks.get('keys', []):
                if jwk.get('kid') == kid:
                    key = jwt.algorithms.RSAAlgorithm.from_jwk(jwk)
                    break

            if not key:
                return jsonify({'error': 'Invalid token key'}), 401

            decoded = jwt.decode(
                token,
                key,
                algorithms=['RS256'],
                options={'verify_aud': False},
                issuer=f"{KEYCLOAK_PUBLIC_URL}/realms/{KEYCLOAK_REALM}",
            )

            request.user = decoded
            request.user_roles = decoded.get('realm_access', {}).get('roles', [])
            request.user_sub = decoded.get('sub')

        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except jwt.InvalidTokenError as e:
            return jsonify({'error': f'Invalid token: {str(e)}'}), 401
        except Exception as e:
            return jsonify({'error': f'Token verification failed: {str(e)}'}), 401

        return f(*args, **kwargs)

    return decorated


def require_role(*allowed_roles):
    def decorator(f):
        @wraps(f)
        @verify_token
        def decorated(*args, **kwargs):
            user_roles = getattr(request, 'user_roles', [])
            if not any(role in user_roles for role in allowed_roles):
                return jsonify({'error': 'Insufficient permissions'}), 403
            return f(*args, **kwargs)

        return decorated

    return decorator


def is_banned(sub: str) -> bool:
    """Verifică dacă un utilizator este banat pentru ticketing."""
    if not sub:
        return False
    return db.session.query(BannedUser.id).filter_by(keycloak_sub=sub).first() is not None


def rate_limit(max_requests: int = 2, window_seconds: int = 60):
    """
    Rate limiting simplu în memorie, per utilizator (keycloak_sub).
    Pentru demo este suficient (avem un singur replica), dar în producție
    s-ar folosi un storage partajat (Redis, etc.).
    """
    store = {}

    def decorator(f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            user_sub = getattr(request, 'user_sub', None)
            if not user_sub:
                return jsonify({'error': 'Missing user context for rate limiting'}), 401

            now = time.time()
            timestamps = [t for t in store.get(user_sub, []) if now - t < window_seconds]

            if len(timestamps) >= max_requests:
                return jsonify({
                    'error': 'Too many requests',
                    'limit': max_requests,
                    'window_seconds': window_seconds
                }), 429

            timestamps.append(now)
            store[user_sub] = timestamps
            return f(*args, **kwargs)

        return wrapped

    return decorator


def publish_ticket_notification(ticket):
    """Trimite un mesaj în RabbitMQ când se cumpără un bilet."""
    try:
        rabbit_host = os.getenv('RABBITMQ_HOST', 'rabbitmq')
        connection = pika.BlockingConnection(pika.ConnectionParameters(host=rabbit_host))
        channel = connection.channel()
        channel.queue_declare(queue='ticket_booked', durable=False)

        payload = {
            'event_id': ticket.event_id,
            'organizer_sub': ticket.event.created_by if ticket.event else None,
            'buyer_sub': ticket.keycloak_sub,
            'code': ticket.code,
            'created_at': datetime.utcnow().isoformat(),
        }
        channel.basic_publish(
            exchange='',
            routing_key='ticket_booked',
            body=json.dumps(payload).encode('utf-8'),
        )
        connection.close()
    except Exception as e:
        # Pentru demo, doar logăm eroarea fără să stricăm flow-ul principal
        print(f"Error publishing RabbitMQ notification: {e}")


# Routes
@app.route('/health', methods=['GET'])
def health():
    return jsonify({'service': 'ticketing-service', 'status': 'ok'}), 200


@app.route('/events', methods=['GET'])
def list_events():
    """Listă toate evenimentele (public)."""
    events = Event.query.order_by(Event.starts_at.asc()).all()
    return jsonify([e.to_dict() for e in events]), 200


@app.route('/events', methods=['POST'])
@require_role('ADMIN', 'ORGANIZER')
def create_event():
    """Creează un nou eveniment (ADMIN / ORGANIZER)."""
    data = request.get_json() or {}

    try:
        name = data['name']
        starts_at_str = data['starts_at']
        total_tickets = int(data.get('total_tickets', 0))
    except (KeyError, ValueError):
        return jsonify({'error': 'name, starts_at, total_tickets sunt obligatorii'}), 400

    try:
        starts_at = datetime.fromisoformat(starts_at_str)
    except ValueError:
        return jsonify({'error': 'starts_at trebuie să fie ISO 8601 (ex: 2025-12-31T18:00:00)'}), 400

    event = Event(
        name=name,
        description=data.get('description'),
        location=data.get('location'),
        starts_at=starts_at,
        total_tickets=total_tickets,
        created_by=getattr(request, 'user_sub', None),
    )
    db.session.add(event)
    db.session.commit()

    return jsonify(event.to_dict()), 201


@app.route('/events/<int:event_id>', methods=['GET'])
def get_event(event_id):
    event = Event.query.get(event_id)
    if not event:
        return jsonify({'error': 'Event not found'}), 404
    return jsonify(event.to_dict()), 200


@app.route('/events/<int:event_id>/tickets', methods=['POST'])
@verify_token
@rate_limit(max_requests=2, window_seconds=60)
def buy_ticket(event_id):
    """Cumpără un bilet pentru utilizatorul curent."""
    if is_banned(request.user_sub):
        return jsonify({'error': 'User is banned from buying tickets'}), 403
    event = Event.query.get(event_id)
    if not event:
        return jsonify({'error': 'Event not found'}), 404

    if event.remaining_tickets() <= 0:
        return jsonify({'error': 'No tickets available'}), 400

    ticket_code = secrets.token_hex(4)  # ex: 8 hex chars, ușor de citit în demo

    ticket = Ticket(
        event_id=event.id,
        keycloak_sub=request.user_sub,
        code=ticket_code,
    )
    event.tickets_sold += 1

    db.session.add(ticket)
    db.session.commit()

    # publica notificare
    publish_ticket_notification(ticket)

    return jsonify(ticket.to_dict()), 201


@app.route('/my-tickets', methods=['GET'])
@verify_token
def my_tickets():
    """Listează toate biletele utilizatorului curent."""
    if is_banned(request.user_sub):
        return jsonify({'error': 'User is banned'}), 403
    tickets = Ticket.query.filter_by(keycloak_sub=request.user_sub).all()
    return jsonify([t.to_dict() for t in tickets]), 200


@app.route('/scan/<code>', methods=['POST'])
@require_role('ADMIN', 'ORGANIZER', 'STAFF')
def scan_ticket(code):
    """Validează un bilet după cod și îl marchează ca folosit."""
    ticket = Ticket.query.filter_by(code=code).first()
    if not ticket:
        return jsonify({'valid': False, 'error': 'Ticket not found'}), 404

    if ticket.used_at is not None:
        return jsonify({
            'valid': False,
            'error': 'Ticket already used',
            'ticket': ticket.to_dict(),
        }), 400

    ticket.used_at = datetime.utcnow()
    ticket.used_by = getattr(request, 'user_sub', None)
    db.session.commit()

    return jsonify({'valid': True, 'ticket': ticket.to_dict()}), 200


@app.route('/admin/banned', methods=['GET'])
@require_role('ADMIN')
def list_banned():
    """Listă utilizatori banați (ADMIN)."""
    banned = BannedUser.query.order_by(BannedUser.created_at.desc()).all()
    return jsonify([b.to_dict() for b in banned]), 200


@app.route('/admin/banned', methods=['POST'])
@require_role('ADMIN')
def ban_user():
    """Ban/unban logic: creează sau actualizează un ban pentru un keycloak_sub."""
    data = request.get_json() or {}
    keycloak_sub = data.get('keycloak_sub')
    reason = data.get('reason', '')

    if not keycloak_sub:
        return jsonify({'error': 'keycloak_sub is required'}), 400

    banned = BannedUser.query.filter_by(keycloak_sub=keycloak_sub).first()
    if not banned:
        banned = BannedUser(keycloak_sub=keycloak_sub, reason=reason)
        db.session.add(banned)
    else:
        banned.reason = reason

    db.session.commit()
    return jsonify(banned.to_dict()), 201


@app.route('/admin/banned/<keycloak_sub>', methods=['DELETE'])
@require_role('ADMIN')
def unban_user(keycloak_sub):
    """Șterge ban-ul unui utilizator (ADMIN)."""
    banned = BannedUser.query.filter_by(keycloak_sub=keycloak_sub).first()
    if not banned:
        return jsonify({'error': 'Not banned'}), 404
    db.session.delete(banned)
    db.session.commit()
    return jsonify({'message': 'User unbanned'}), 200


if __name__ == '__main__':
    with app.app_context():
        db.create_all()

    port = int(os.getenv('PORT', 3005))
    app.run(host='0.0.0.0', port=port, debug=False)




